(begin <MacroFunction (condition success failure) (list (quote cond) (list condition success) (list t failure))> <MacroFunction (signature body) (cond ((listp signature) (list (quote set) (list (quote quote) (head signature)) (list (quote lambda) (tail signature) body))) (t (list (quote set) (list (quote quote) signature) body)))> (set (quote range-inclusive) (lambda (start end) (cond ((< (- end start) 0.0) nil) (t (cons start (range-inclusive (+ start 1.0) end)))))))
=> <Function (start end) (cond ((< (- end start) 0.0) nil) (t (cons start (range-inclusive (+ start 1.0) end))))>
(cond (t "Yay") (t "Nay"))
=> "Yay"
(set (quote print) (lambda (a) (begin (print-raw (to-string a)) (print-line))))
=> <Function (a) (begin (print-raw (to-string a)) (print-line))>
(print-line)

=> nil
"plus function - implements '+'"
=> "plus function - implements '+'"
(set (quote plus) (lambda (x y) (+ x y)))
=> <Function (x y) (+ x y)>
plus
=> <Function (x y) (+ x y)>
(plus 3.0 5.0)
=> 8.0
(print-line)

=> nil
"p function - print"
=> "p function - print"
(set (quote p) (lambda (a) (begin (print a))))
=> <Function (a) (begin (print a))>
(p "Test printing one thing from new function")
"Test printing one thing from new function"
=> nil
(p "Test printing another thing from new function")
"Test printing another thing from new function"
=> nil
(print-line)

=> nil
"Head and tail of a list (a b c)"
=> "Head and tail of a list (a b c)"
(set (quote l) (list "a" "b" "c"))
=> ("a" "b" "c")
(head l)
=> "a"
(tail l)
=> ("b" "c")
(print-line)

=> nil
"p2 - print twice."
=> "p2 - print twice."
(set (quote p2) (lambda (a) (begin (print a) (print a))))
=> <Function (a) (begin (print a) (print a))>
(p2 "Test double print")
"Test double print"
"Test double print"
=> nil
(print-line)

=> nil
"fib sequence - 0 1 2 3 4 5 6"
=> "fib sequence - 0 1 2 3 4 5 6"
(set (quote fib) (lambda (n) (cond ((= n 0.0) 0.0) ((= n 1.0) 1.0) (t (+ (fib (- n 2.0)) (fib (- n 1.0)))))))
=> <Function (n) (cond ((= n 0.0) 0.0) ((= n 1.0) 1.0) (t (+ (fib (- n 2.0)) (fib (- n 1.0)))))>
(fib 0.0)
=> 0.0
(fib 1.0)
=> 1.0
(fib 2.0)
=> 1.0
(fib 3.0)
=> 2.0
(fib 4.0)
=> 3.0
(fib 5.0)
=> 5.0
(fib 6.0)
=> 8.0
(print-line)

=> nil
"count - find the number of values in the input."
=> "count - find the number of values in the input."
(set (quote count) (lambda (l) (cond ((null l) 0.0) (t (+ 1.0 (count (tail l)))))))
=> <Function (l) (cond ((null l) 0.0) (t (+ 1.0 (count (tail l)))))>
(count (quote ("a" "b" "c")))
=> 3.0
(cond (f "false") (t "true"))
=> "true"
(print-line)

=> nil
"print - pretty-print the input."
=> "print - pretty-print the input."
(quote ("a" "b" "c"))
=> ("a" "b" "c")
"hello"
=> "hello"
(print-line)

=> nil
"not - returns the opposite boolean value for the given input."
=> "not - returns the opposite boolean value for the given input."
(set (quote not) (lambda (a) (eq a nil)))
=> <Function (a) (eq a nil)>
(not t)
=> nil
(not nil)
=> t
(print-line)

=> nil
"cons - constructs an object from two other objects."
=> "cons - constructs an object from two other objects."
(cons "hello" "h")
=> "hello"Â·"h"
(cons "a" (quote ("b" "c")))
=> ("a" "b" "c")
(print-line)

=> nil
"lambda invocation - applies arguments to a lambda function."
=> "lambda invocation - applies arguments to a lambda function."
((lambda (x) (+ x x)) 10.0)
=> 20.0
(print-line)

=> nil
"begin - builtin function for combining multiple statements."
=> "begin - builtin function for combining multiple statements."
(begin "Hello" "Hello2")
=> "Hello2"
(print-line)

=> nil
(print "singleton - returns a list containing the given item.")
"singleton - returns a list containing the given item."
=> nil
(set (quote singleton) (lambda (x) (cons x nil)))
=> <Function (x) (cons x nil)>
(set (quote reverse) (lambda (l) (reverse-aux l nil)))
=> <Function (l) (reverse-aux l nil)>
(set (quote reverse-aux) (lambda (l a) (cond ((null l) a) (t (reverse-aux (tail l) (cons (head l) a))))))
=> <Function (l a) (cond ((null l) a) (t (reverse-aux (tail l) (cons (head l) a))))>
(print-line)

=> nil
"reverse - returns the reverse of the input."
=> "reverse - returns the reverse of the input."
reverse-aux
=> <Function (l a) (cond ((null l) a) (t (reverse-aux (tail l) (cons (head l) a))))>
(reverse nil)
=> nil
(reverse (list "a"))
=> ("a")
(reverse (quote ("a" "b")))
=> ("b" "a")
(reverse (quote ("a" "b" "c")))
=> ("c" "b" "a")
(print-line)

=> nil
"palendromep - checks if the input is a palendrome."
=> "palendromep - checks if the input is a palendrome."
(set (quote palendromep) (lambda (p) (cond ((null l) t) ((eq p (reverse p)) t))))
=> <Function (p) (cond ((null l) t) ((eq p (reverse p)) t))>
(palendromep (quote ("a" "b" "c")))
=> t
(palendromep (quote ("a" "b" "c" "b" "a")))
=> t
(print-line)

=> nil
"Locally-scoped variables - no trace of x or y outside of foo."
=> "Locally-scoped variables - no trace of x or y outside of foo."
(set (quote foo) (lambda (x) (begin (set (quote y) x) (print x) (print y))))
=> <Function (x) (begin (set (quote y) x) (print x) (print y))>
(foo 11.0)
11.0
11.0
=> nil
x
=> nil
y
=> nil
(print-line)

=> nil
"<="
=> "<="
(set (quote <=) (lambda (a b) (or (= a b) (< a b))))
=> <Function (a b) (or (= a b) (< a b))>
(print-line)

=> nil
"Nth item in list - 1 based"
=> "Nth item in list - 1 based"
(set (quote nth) (lambda (l n) (cond ((> n 1.0) (nth (tail l) (- n 1.0))) (t (head l)))))
=> <Function (l n) (cond ((> n 1.0) (nth (tail l) (- n 1.0))) (t (head l)))>
(nth (list "a" "b" "c") 3.0)
=> "c"
(nth (list "a" "b" "c") 2.0)
=> "b"
(nth (list "a" "b" "c") 1.0)
=> "a"
(print-line)

=> nil
"List operations - map."
=> "List operations - map."
(set (quote map) (lambda (l f) (cond ((null l) nil) (t (cons (f (head l)) (map (tail l) f))))))
=> <Function (l f) (cond ((null l) nil) (t (cons (f (head l)) (map (tail l) f))))>
(map (list 1.0 2.0 3.0) (lambda (x) (+ x 100.0)))
=> (101.0 102.0 103.0)
(print-line)

=> nil
"List operations - filter."
=> "List operations - filter."
(set (quote filter) (lambda (l f) (cond ((null l) nil) ((f (head l)) (cons (head l) (filter (tail l) f))) (t (filter (tail l) f)))))
=> <Function (l f) (cond ((null l) nil) ((f (head l)) (cons (head l) (filter (tail l) f))) (t (filter (tail l) f)))>
(filter (list 1.0 2.0 3.0) (lambda (x) (not (= x 2.0))))
=> (1.0 3.0)
(print-line)

=> nil
"List operations - take n."
=> "List operations - take n."
(set (quote take) (lambda (l n) (cond ((null l) nil) ((> n 0.0) (cons (head l) (take (tail l) (- n 1.0)))))))
=> <Function (l n) (cond ((null l) nil) ((> n 0.0) (cons (head l) (take (tail l) (- n 1.0)))))>
(take (list "a" "b" "c" "d") 2.0)
=> ("a" "b")
(take (list "a" "b" "c" "d" "e") 4.0)
=> ("a" "b" "c" "d")
(take (list 1.0 2.0 3.0) 0.0)
=> nil
(take (list 1.0 2.0 3.0) 4.0)
=> (1.0 2.0 3.0)
(print-line)

=> nil
"List operations - drop n."
=> "List operations - drop n."
(set (quote drop) (lambda (l n) (cond ((null l) nil) ((> n 0.0) (drop (tail l) (- n 1.0))) (t l))))
=> <Function (l n) (cond ((null l) nil) ((> n 0.0) (drop (tail l) (- n 1.0))) (t l))>
(drop (list "a" "b" "c") 1.0)
=> ("b" "c")
(drop (list "a" "b" "c") 2.0)
=> ("c")
(drop (list "a" "b" "c") 3.0)
=> nil
(drop (list "a" "b" "c") 4.0)
=> nil
(print-line)

=> nil
"List operations - concat - O(n) for a."
=> "List operations - concat - O(n) for a."
(set (quote concat) (lambda (a b) (cond ((null a) b) ((null b) a) (t (cons (head a) (concat (tail a) b))))))
=> <Function (a b) (cond ((null a) b) ((null b) a) (t (cons (head a) (concat (tail a) b))))>
(concat (list "a" "b") (list "c"))
=> ("a" "b" "c")
(concat (list 1.0 2.0 3.0) (list 4.0 5.0 6.0 7.0))
=> (1.0 2.0 3.0 4.0 5.0 6.0 7.0)
(print-line)

=> nil
"List operations - flatmap."
=> "List operations - flatmap."
(set (quote flat-map) (lambda (l f) (cond ((null l) nil) (t (concat (f (head l)) (flat-map (tail l) f))))))
=> <Function (l f) (cond ((null l) nil) (t (concat (f (head l)) (flat-map (tail l) f))))>
(flat-map (list 1.0 2.0 3.0) (lambda (x) (list x x)))
=> (1.0 1.0 2.0 2.0 3.0 3.0)
(print-line)

=> nil
"List operations - reduce."
=> "List operations - reduce."
(set (quote reduce) (lambda (l acc f) (cond ((null l) acc) (t (reduce (tail l) (f acc (head l)) f)))))
=> <Function (l acc f) (cond ((null l) acc) (t (reduce (tail l) (f acc (head l)) f)))>
(reduce (list 1.0 2.0 3.0 4.0) 0.0 (lambda (acc x) (+ acc x)))
=> 10.0
(reduce (list 1.0 2.0 3.0 4.0 8.0 7.0 6.0 9.0 5.0) 0.0 (lambda (acc x) (cond ((> x acc) x) (t acc))))
=> 9.0
(print-line)

=> nil
"List operations - sum."
=> "List operations - sum."
(set (quote sum) (lambda (l) (reduce l 0.0 (lambda (acc x) (+ acc x)))))
=> <Function (l) (reduce l 0.0 (lambda (acc x) (+ acc x)))>
(sum (list 1.0 2.0 3.0 4.0))
=> 10.0
(sum (list 2.0 2.0 2.0))
=> 6.0
(print-line)

=> nil
"List operations - max."
=> "List operations - max."
(set (quote max) (lambda (l) (reduce l (head l) (lambda (acc x) (cond ((> x acc) x) (t acc))))))
=> <Function (l) (reduce l (head l) (lambda (acc x) (cond ((> x acc) x) (t acc))))>
(max (list 1.0 2.0 3.0 4.0))
=> 4.0
(max (list 2.0 4.0 1.0 3.0 4.0 2.0 1.0))
=> 4.0
(print-line)

=> nil
"List operations - min."
=> "List operations - min."
(set (quote min) (lambda (l) (reduce l (head l) (lambda (acc x) (cond ((< x acc) x) (t acc))))))
=> <Function (l) (reduce l (head l) (lambda (acc x) (cond ((< x acc) x) (t acc))))>
(min (list 1.0 2.0 3.0 4.0))
=> 1.0
(min (list 4.0 1.0 3.0 2.0))
=> 1.0
(print-line)

=> nil
"List operations - split."
=> "List operations - split."
(set (quote halves) (lambda (l) (begin (set (quote hc) (/ (count l) 2.0)) (list (take l hc) (drop l hc)))))
=> <Function (l) (begin (set (quote hc) (/ (count l) 2.0)) (list (take l hc) (drop l hc)))>
(halves nil)
=> (nil nil)
(halves (list 1.0 2.0 3.0 4.0 5.0))
=> (nil nil)
(halves (list 1.0 1.0 2.0 3.0 5.0 8.0))
=> (nil nil)
(halves (list 1.0 2.0))
=> (nil nil)
(print-line)

=> nil
"List operations - join sorted. Optional comparison function."
=> "List operations - join sorted. Optional comparison function."
(set (quote join-sorted) (lambda (a b f) (cond ((null a) b) ((null b) a) (((cond (f f) (t <)) (head a) (head b)) (cons (head a) (join-sorted (tail a) b f))) (t (cons (head b) (join-sorted a (tail b) f))))))
=> <Function (a b f) (cond ((null a) b) ((null b) a) (((cond (f f) (t <)) (head a) (head b)) (cons (head a) (join-sorted (tail a) b f))) (t (cons (head b) (join-sorted a (tail b) f))))>
(join-sorted (list 1.0 2.0 3.0 4.0 5.0) (list 6.0 7.0 8.0 9.0))
=> (1.0 2.0 3.0 4.0 5.0 6.0 7.0 8.0 9.0)
(join-sorted (list 5.0 6.0 7.0 8.0) (list 1.0 2.0 3.0 4.0))
=> (1.0 2.0 3.0 4.0 5.0 6.0 7.0 8.0)
(join-sorted (list 1.0 3.0 5.0 7.0) (list 2.0 4.0 6.0 8.0))
=> (1.0 2.0 3.0 4.0 5.0 6.0 7.0 8.0)
(join-sorted nil (list 4.0 5.0 6.0))
=> (4.0 5.0 6.0)
(join-sorted (list 3.0 4.0) nil)
=> (3.0 4.0)
(join-sorted (list 4.0 2.0) (list 5.0 3.0 1.0) >)
=> (5.0 4.0 3.0 2.0 1.0)
(print-line)

=> nil
"List operations - merge sort. Optional comparison function."
=> "List operations - merge sort. Optional comparison function."
(set (quote sort) (lambda (l f) (cond ((null l) l) ((null (tail l)) l) (t (join-sorted (sort (head (halves l)) f) (sort (head (tail (halves l))) f) f)))))
=> <Function (l f) (cond ((null l) l) ((null (tail l)) l) (t (join-sorted (sort (head (halves l)) f) (sort (head (tail (halves l))) f) f)))>
(sort (list 1.0 2.0 3.0 4.0 5.0))
=> nil
(sort (list 5.0 4.0 3.0 2.0 1.0))
=> nil
(sort (list 1.0 3.0 5.0 3.0 4.0 4.0 2.0 0.0))
=> nil
(sort (list 1.0 3.0 5.0 3.0 4.0 4.0 2.0 0.0) >)
=> nil
(print-line)

=> nil
"Function with bound scope."
=> "Function with bound scope."
(set (quote generate-incrementer) (lambda nil (begin (set (quote x) 0.0) (lambda nil (begin (set (quote x) (+ x 1.0)) x)))))
=> <Function nil (begin (set (quote x) 0.0) (lambda nil (begin (set (quote x) (+ x 1.0)) x)))>
(set (quote incrementer1) (generate-incrementer))
=> <Function nil (begin (set (quote x) (+ x 1.0)) x)>
(incrementer1)
=> 1.0
(incrementer1)
=> 2.0
(set (quote incrementer2) (generate-incrementer))
=> <Function nil (begin (set (quote x) (+ x 1.0)) x)>
(incrementer2)
=> 1.0
(incrementer1)
=> 3.0
x
=> nil
(print-line)

=> nil
"Let"
=> "Let"
(let ((x 2.0) (y 3.0)) (+ x y))
=> 5.0
(let ((x 2.0) (y 3.0)) (+ x y) (* x y))
=> 6.0
x
=> nil
y
=> nil
(print-line)

=> nil
"macro - a type of function which operates on un-evaluated arguments and returns a statement which is then evaluated in the calling scope."
=> "macro - a type of function which operates on un-evaluated arguments and returns a statement which is then evaluated in the calling scope."
<MacroFunction (condition success failure) (list (quote cond) (list condition success) (list t failure))>
=> <MacroFunction (condition success failure) (list (quote cond) (list condition success) (list t failure))>
(cond (t "True") (t "False"))
=> "True"
(cond (nil "True") (t "False"))
=> "False"
(print-line)

=> nil
"listp - Checks if the given value is a pair or nil."
=> "listp - Checks if the given value is a pair or nil."
(listp nil)
=> t
(listp t)
=> nil
(listp 1.0)
=> nil
(listp (quote ("a" "b")))
=> t
(listp (list "a" "b" "c"))
=> t
(listp (cons "a" "b"))
=> t
(print-line)

=> nil
"define - A macro for defining either a variable or a function depending on the arguments."
=> "define - A macro for defining either a variable or a function depending on the arguments."
(set (quote a) "A")
=> "A"
a
=> "A"
(set (quote double) (lambda (a) (+ a a)))
=> <Function (a) (+ a a)>
(double 2.0)
=> 4.0
(print-line)

=> nil
"factorial defined with lambda"
=> "factorial defined with lambda"
(set (quote factorial-lambda) (lambda (n) (cond ((<= n 0.0) 1.0) (t (* n (factorial-lambda (- n 1.0)))))))
=> <Function (n) (cond ((<= n 0.0) 1.0) (t (* n (factorial-lambda (- n 1.0)))))>
(factorial-lambda 0.0)
=> 1.0
(factorial-lambda 1.0)
=> 1.0
(factorial-lambda 2.0)
=> 2.0
(factorial-lambda 3.0)
=> 6.0
(factorial-lambda 10.0)
=> 3628800.0
(print-line)

=> nil
"factorial defined with special define syntax"
=> "factorial defined with special define syntax"
(set (quote factorial-special) (lambda (n) (cond ((<= n 0.0) 1.0) (t (* n (factorial-special (- n 1.0)))))))
=> <Function (n) (cond ((<= n 0.0) 1.0) (t (* n (factorial-special (- n 1.0)))))>
factorial-special
=> <Function (n) (cond ((<= n 0.0) 1.0) (t (* n (factorial-special (- n 1.0)))))>
(factorial-special 0.0)
=> 1.0
(factorial-special 1.0)
=> 1.0
(factorial-special 2.0)
=> 2.0
(factorial-special 3.0)
=> 6.0
(factorial-special 10.0)
=> 3628800.0
(print-line)

=> nil
"dedup-consecutives"
=> "dedup-consecutives"
(set (quote dedup-consecutives) (lambda (l previous-letter) (cond ((null l) nil) ((eq previous-letter (head l)) (dedup-consecutives (tail l) (head l))) (t (cons (head l) (dedup-consecutives (tail l) (head l)))))))
=> <Function (l previous-letter) (cond ((null l) nil) ((eq previous-letter (head l)) (dedup-consecutives (tail l) (head l))) (t (cons (head l) (dedup-consecutives (tail l) (head l)))))>
(dedup-consecutives (list "a" "a" "a" "a" "b" "c" "c" "a" "a" "d" "e" "e" "e" "e"))
=> ("a" "b" "c" "a" "d" "e")
(print-line)

=> nil
"range-inclusive"
=> "range-inclusive"
range-inclusive
=> <Function (start end) (cond ((< (- end start) 0.0) nil) (t (cons start (range-inclusive (+ start 1.0) end))))>
(range-inclusive 0.0 10.0)
=> (0.0 1.0 2.0 3.0 4.0 5.0 6.0 7.0 8.0 9.0 10.0)
(range-inclusive 0.0 0.0)
=> (0.0)
(range-inclusive 4.0 9.0)
=> (4.0 5.0 6.0 7.0 8.0 9.0)
(print-line)

=> nil
"hashmap functions"
=> "hashmap functions"
<MacroFunction (values) (list (quote make-hash-eval) (list (quote quote) values))>
=> <MacroFunction (values) (list (quote make-hash-eval) (list (quote quote) values))>
<MacroFunction (values) (list (quote make-hash-eval) (list (quote quote) values))>
=> <MacroFunction (values) (list (quote make-hash-eval) (list (quote quote) values))>
(make-hash-eval (quote nil))
=> <Map>
(set (quote attributes-map) (make-hash-eval (quote (("price" 10.0) ("width" 5.0) ("depth" 20.0) ("name" "Harold")))))
=> <Map ("price" 10.0) ("width" 5.0) ("depth" 20.0) ("name" "Harold")>
attributes-map
=> <Map ("price" 10.0) ("width" 5.0) ("depth" 20.0) ("name" "Harold")>
(hash-get attributes-map "price")
=> 10.0
(hash-get attributes-map "height")
=> nil
(hash-set attributes-map "price" 20.0)
=> <Map ("price" 20.0) ("width" 5.0) ("depth" 20.0) ("name" "Harold")>
attributes-map
=> <Map ("price" 20.0) ("width" 5.0) ("depth" 20.0) ("name" "Harold")>
(hash-get attributes-map "price")
=> 20.0
(print-line)

=> nil
"set functions"
=> "set functions"
<MacroFunction (values) (list (quote make-hash-eval) (list (quote map) (cons (quote list) values) (quote (lambda (v) (list v t)))))>
=> <MacroFunction (values) (list (quote make-hash-eval) (list (quote map) (cons (quote list) values) (quote (lambda (v) (list v t)))))>
(set (quote set-add) (lambda (s value) (hash-set s value t)))
=> <Function (s value) (hash-set s value t)>
(set (quote set-contains) (lambda (s value) (hash-get s value)))
=> <Function (s value) (hash-get s value)>
(set (quote attributes-set) (make-hash-eval (map (list "a" "b" "c") (lambda (v) (list v t)))))
=> <Map ("a" t) ("b" t) ("c" t)>
(set-add attributes-set "d")
=> <Map ("a" t) ("b" t) ("c" t) ("d" t)>
(set-add attributes-set "d")
=> <Map ("a" t) ("b" t) ("c" t) ("d" t)>
(set-contains attributes-set "e")
=> nil
(set-contains attributes-set "a")
=> t
(print-line)

=> nil
"Run an operation in a new thread."
=> "Run an operation in a new thread."
(print "Hello")
"Hello"
=> nil
(thread (print "Hello"))
=> nil
"Hello"