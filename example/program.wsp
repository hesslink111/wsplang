(load "std.wsp")

(if t "Yay" "Nay")

(set 'print
  (lambda (a)
    (begin
      (print-raw (to-string a))
      (print-line))))

(print-line)
"plus function - implements '+'"
(set 'plus (lambda (x y) (+ x y)))
plus
(plus 3 5)

(print-line)
"p function - print"
(set 'p (lambda (a) (begin (print a))))
(p "Test printing one thing from new function")
(p "Test printing another thing from new function")

(print-line)
"Head and tail of a list (a b c)"
(set 'l (list "a" "b" "c"))
(head l)
(tail l)

(print-line)
"p2 - print twice."
(set 'p2
  (lambda (a)
    (begin
      (print a)
      (print a))))
(p2 "Test double print")

(print-line)
"fib sequence - 0 1 2 3 4 5 6"
(set 'fib
  (lambda (n)
    (cond
      ((= n 0) 0)
      ((= n 1) 1)
      (t (+ (fib (- n 2)) (fib (- n 1)))))))
(fib 0)
(fib 1)
(fib 2)
(fib 3)
(fib 4)
(fib 5)
(fib 6)

(print-line)
"count - find the number of values in the input."
(count '("a" "b" "c"))
(cond (f "false") (t "true"))

(print-line)
"print - pretty-print the input."
'("a" "b" "c")
"hello"

// Not
(print-line)
"not - returns the opposite boolean value for the given input."
(set 'not
  (lambda (a)
    (eq a ())))
(not t)
(not ())

(print-line)
"cons - constructs an object from two other objects."
(cons "hello" "h")
(cons "a" '("b" "c"))

(print-line)
"lambda invocation - applies arguments to a lambda function."
((lambda (x) (+ x x)) 10)

(print-line)
"begin - builtin function for combining multiple statements."
(begin
  "Hello"
  "Hello2")

(print-line)
(print "singleton - returns a list containing the given item.")
(set 'singleton
  (lambda (x)
    (cons x ())))

(print-line)
"reverse - returns the reverse of the input."
reverse-aux
(reverse ())
(reverse (list "a"))
(reverse '("a" "b"))
(reverse '("a" "b" "c"))

(print-line)
"palendromep - checks if the input is a palendrome."
(set 'palendromep
  (lambda (p)
    (cond
      ((null l) t)
      ((eq p (reverse p)) t))))
(palendromep '("a" "b" "c"))
(palendromep '("a" "b" "c" "b" "a"))

(print-line)
"Locally-scoped variables - no trace of x or y outside of foo."
(set 'foo
  (lambda (x)
    (begin
      (set 'y x)
      (print x)
      (print y))))
(foo 11)
x
y

(print-line)
"<="
(set '<=
  (lambda (a b)
    (or (= a b) (< a b))))

(print-line)
"Nth item in list - 1 based"
(nth (list "a" "b" "c") 3)
(nth (list "a" "b" "c") 2)
(nth (list "a" "b" "c") 1)

(print-line)
"List operations - map."
(map (list 1 2 3) (lambda (x) (+ x 100)))

(print-line)
"List operations - filter."
(filter (list 1 2 3) (lambda (x) (not (= x 2))))

(print-line)
"List operations - take n."
(take (list "a" "b" "c" "d") 2)
(take (list "a" "b" "c" "d" "e") 4)
(take (list 1 2 3) 0)
(take (list 1 2 3) 4)

(print-line)
"List operations - drop n."
(drop (list "a" "b" "c") 1)
(drop (list "a" "b" "c") 2)
(drop (list "a" "b" "c") 3)
(drop (list "a" "b" "c") 4)

(print-line)
"List operations - concat - O(n) for a."
(concat (list "a" "b") (list "c"))
(concat (list 1 2 3) (list 4 5 6 7))

(print-line)
"List operations - flatmap."
(flat-map (list 1 2 3) (lambda (x) (list x x)))

(print-line)
"List operations - reduce."
(reduce (list 1 2 3 4) 0 (lambda (acc x) (+ acc x)))
(reduce (list 1 2 3 4 8 7 6 9 5) 0 (lambda (acc x) (cond ((> x acc) x) (t acc))))

(print-line)
"List operations - sum."
(sum (list 1 2 3 4))
(sum (list 2 2 2))

(print-line)
"List operations - max."
(max (list 1 2 3 4))
(max (list 2 4 1 3 4 2 1))

(print-line)
"List operations - min."
(min (list 1 2 3 4))
(min (list 4 1 3 2))

(print-line)
"List operations - split."
halves
(halves ())
(halves (list 1 2 3 4 5))
(halves (list 1 1 2 3 5 8))
(halves (list 1 2))

(print-line)
"List operations - join sorted. Optional comparison function."
(join-sorted (list 1 2 3 4 5) (list 6 7 8 9))
(join-sorted (list 5 6 7 8) (list 1 2 3 4))
(join-sorted (list 1 3 5 7) (list 2 4 6 8))
(join-sorted () (list 4 5 6))
(join-sorted (list 3 4) ())
(join-sorted (list 4 2) (list 5 3 1) >)

(print-line)
"List operations - merge sort. Optional comparison function."
(sort (list 1 2 3 4 5))
(sort (list 5 4 3 2 1))
(sort (list 1 3 5 3 4 4 2 0))
(sort (list 1 3 5 3 4 4 2 0) >)

(print-line)
"Function with bound scope."
(set 'generate-incrementer
  (lambda ()
    (begin
      (set 'x 0)
      (lambda ()
        (begin
          (set 'x (+ x 1))
          x)))))
(set 'incrementer1 (generate-incrementer))
(incrementer1)
(incrementer1)
(set 'incrementer2 (generate-incrementer))
(incrementer2)
(incrementer1)
x

(print-line)
"Let"
(let ((x 2) (y 3))
  (+ x y))
(let ((x 2) (y 3))
  (+ x y)
  (* x y))
x
y

(print-line)
"macro - a type of function which operates on un-evaluated arguments and returns a statement which is then evaluated in the calling scope."
if
(if t "True" "False")
(if () "True" "False")

(print-line)
"listp - Checks if the given value is a pair or nil."
(listp ())
(listp t)
(listp 1)
(listp '("a" "b"))
(listp (list "a" "b" "c"))
(listp (cons "a" "b"))

(print-line)
"define - A macro for defining either a variable or a function depending on the arguments."
(define a "A")
a
(define (double a) (+ a a))
(double 2)

(print-line)
"factorial defined with lambda"
(define factorial-lambda
  (lambda (n)
    (if (<= n 0)
      1
      (* n (factorial-lambda (- n 1))))))
(factorial-lambda 0)
(factorial-lambda 1)
(factorial-lambda 2)
(factorial-lambda 3)
(factorial-lambda 10)

(print-line)
"factorial defined with special define syntax"
(define (factorial-special n)
    (if (<= n 0)
      1
      (* n (factorial-special (- n 1)))))
factorial-special
(factorial-special 0)
(factorial-special 1)
(factorial-special 2)
(factorial-special 3)
(factorial-special 10)

(print-line)
"dedup-consecutives"
(define (dedup-consecutives l previous-letter)
  (cond
    ((null l) ())
    ((eq previous-letter (head l)) (dedup-consecutives (tail l) (head l)))
    (t (cons (head l) (dedup-consecutives (tail l) (head l))))))
(dedup-consecutives (list "a" "a" "a" "a" "b" "c" "c" "a" "a" "d" "e" "e" "e" "e"))

(print-line)
"range-inclusive"
range-inclusive
(range-inclusive 0 10)
(range-inclusive 0 0)
(range-inclusive 4 9)

(print-line)
"range-exclusive"
range-exclusive
(range-exclusive 0 10)
(range-exclusive 0 0)
(range-exclusive 4 9)

(print-line)
"hashmap functions"
make-map
(make-map)
(define attributes-map (make-map (("price" 10) ("width" 5) ("depth" 20) ("name" "Harold"))))
attributes-map
(hash-get attributes-map "price")
(hash-get attributes-map "height")
(hash-set attributes-map "price" 20)
attributes-map
(hash-get attributes-map "price")

(print-line)
"set functions"
(define attributes-set (make-map ("a" "b" "c")))
(set-add attributes-set "d")
(set-add attributes-set "d")
(set-contains attributes-set "e")
(set-contains attributes-set "a")

(print-line)
"Run an operation in a new thread."
(print "Hello")
(thread (print "Hello"))
