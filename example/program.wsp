(set 'print
  (lambda (a)
    (progn
      (print-raw (to-string a))
      (print-line))))

(print-line)
"plus function - implements '+'"
(set 'plus (lambda (x y) (+ x y)))
plus
(plus 3 5)

(print-line)
"p function - print"
(set 'p (lambda (a) (progn (print a))))
(p "Test printing one thing from new function")
(p "Test printing another thing from new function")

(print-line)
"Head and tail of a list (a b c)"
(set 'l (list "a" "b" "c"))
(head l)
(tail l)

(print-line)
"p2 - print twice."
(set 'p2
  (lambda (a)
    (progn
      (print a)
      (print a))))
(p2 "Test double print")

(print-line)
"fib sequence - 0 1 2 3 4 5 6"
(set 'fib
  (lambda (n)
    (cond
      ((= n 0) 0)
      ((= n 1) 1)
      (t (+ (fib (- n 2)) (fib (- n 1)))))))
(fib 0)
(fib 1)
(fib 2)
(fib 3)
(fib 4)
(fib 5)
(fib 6)

(print-line)
"count - find the number of values in the input."
(set 'count
  (lambda (l)
    (cond
      ((null l) 0)
      (t (+ 1 (count (tail l)))))))
(count '("a" "b" "c"))
(cond (f "false") (t "true"))

(print-line)
"print - pretty-print the input."
'("a" "b" "c")
"hello"

// Not
(print-line)
"not - returns the opposite boolean value for the given input."
(set 'not
  (lambda (a)
    (eq a ())))
(not t)
(not ())

(print-line)
"cons - constructs an object from two other objects."
(cons "hello" "h")
(cons "a" '("b" "c"))

(print-line)
"lambda invocation - applies arguments to a lambda function."
((lambda (x) (+ x x)) 10)

(print-line)
"progn - builtin function for combining multiple statements."
(progn
  "Hello"
  "Hello2")

(print-line)
(print "singleton - returns a list containing the given item.")
(set 'singleton
  (lambda (x)
    (cons x ())))

(set 'reverse
  (lambda (l)
    (reverse-aux l ())))
(set 'reverse-aux
  (lambda (l a)
    (cond
      ((null l) a)
      (t (reverse-aux (tail l) (cons (head l) a))))))

(print-line)
"reverse - returns the reverse of the input."
reverse-aux
(reverse ())
(reverse (list "a"))
(reverse '("a" "b"))
(reverse '("a" "b" "c"))

(print-line)
"palendromep - checks if the input is a palendrome."
(set 'palendromep
  (lambda (p)
    (cond
      ((null l) t)
      ((eq p (reverse p)) t))))
(palendromep '("a" "b" "c"))
(palendromep '("a" "b" "c" "b" "a"))

(print-line)
"Locally-scoped variables - no trace of x or y outside of foo."
(set 'foo
  (lambda (x)
    (progn
      (set 'y x)
      (print x)
      (print y))))
(foo 11)
x
y

(print-line)
"<="
(set '<=
  (lambda (a b)
    (or (= a b) (< a b))))

(print-line)
"Nth item in list - 1 based"
(set 'nth
  (lambda (l n)
    (cond
      ((> n 1) (nth (tail l) (- n 1)))
      (t (head l)))))
(nth (list "a" "b" "c") 3)
(nth (list "a" "b" "c") 2)
(nth (list "a" "b" "c") 1)

(print-line)
"List operations - map."
(set 'map
  (lambda (l f)
    (cond
      ((null l) ())
      (t (cons (f (head l)) (map (tail l) f))))))
(map (list 1 2 3) (lambda (x) (+ x 100)))

(print-line)
"List operations - filter."
(set 'filter
  (lambda (l f)
    (cond
      ((null l) ())
      ((f (head l)) (cons (head l) (filter (tail l) f)))
      (t (filter (tail l) f)))))
(filter (list 1 2 3) (lambda (x) (not (= x 2))))

(print-line)
"List operations - take n."
(set 'take
  (lambda (l n)
    (cond
      ((null l) ())
      ((> n 0) (cons (head l) (take (tail l) (- n 1)))))))
(take (list "a" "b" "c" "d") 2)
(take (list "a" "b" "c" "d" "e") 4)
(take (list 1 2 3) 0)
(take (list 1 2 3) 4)

(print-line)
"List operations - drop n."
(set 'drop
  (lambda (l n)
    (cond
      ((null l) ())
      ((> n 0) (drop (tail l) (- n 1)))
      (t l))))
(drop (list "a" "b" "c") 1)
(drop (list "a" "b" "c") 2)
(drop (list "a" "b" "c") 3)
(drop (list "a" "b" "c") 4)

(print-line)
"List operations - concat - O(n) for a."
(set 'concat
  (lambda (a b)
    (cond
      ((null a) b)
      ((null b) a)
      (t (cons (head a) (concat (tail a) b))))))
(concat (list "a" "b") (list "c"))
(concat (list 1 2 3) (list 4 5 6 7))

(print-line)
"List operations - flatmap."
(set 'flat-map
  (lambda (l f)
    (cond
      ((null l) ())
      (t (concat (f (head l)) (flat-map (tail l) f))))))
(flat-map (list 1 2 3) (lambda (x) (list x x)))

(print-line)
"List operations - reduce."
(set 'reduce
  (lambda (l acc f)
    (cond
      ((null l) acc)
      (t (reduce (tail l) (f acc (head l)) f)))))
(reduce (list 1 2 3 4) 0 (lambda (acc x) (+ acc x)))
(reduce (list 1 2 3 4 8 7 6 9 5) 0 (lambda (acc x) (cond ((> x acc) x) (t acc))))

(print-line)
"List operations - sum."
(set 'sum
  (lambda (l)
    (reduce l 0 (lambda (acc x) (+ acc x)))))
(sum (list 1 2 3 4))
(sum (list 2 2 2))

(print-line)
"List operations - max."
(set 'max
  (lambda (l)
    (reduce l (head l) (lambda (acc x) (cond ((> x acc) x) (t acc))))))
(max (list 1 2 3 4))
(max (list 2 4 1 3 4 2 1))

(print-line)
"List operations - min."
(set 'min
  (lambda (l)
    (reduce l (head l) (lambda (acc x) (cond ((< x acc) x) (t acc))))))
(min (list 1 2 3 4))
(min (list 4 1 3 2))

(print-line)
"List operations - split."
(set 'halves
  (lambda (l)
    (progn
      (set 'hc (/ (count l) 2))
      (list (take l hc) (drop l hc)))))
(halves ())
(halves (list 1 2 3 4 5))
(halves (list 1 1 2 3 5 8))
(halves (list 1 2))

(print-line)
"List operations - join sorted. Optional comparison function."
(set 'join-sorted
  (lambda (a b f)
    (cond
      ((null a) b)
      ((null b) a)
      (((cond (f f) (t <)) (head a) (head b)) (cons (head a) (join-sorted (tail a) b f)))
      (t (cons (head b) (join-sorted a (tail b) f))))))
(join-sorted (list 1 2 3 4 5) (list 6 7 8 9))
(join-sorted (list 5 6 7 8) (list 1 2 3 4))
(join-sorted (list 1 3 5 7) (list 2 4 6 8))
(join-sorted () (list 4 5 6))
(join-sorted (list 3 4) ())
(join-sorted (list 4 2) (list 5 3 1) >)

(print-line)
"List operations - merge sort. Optional comparison function."
(set 'sort
  (lambda (l f)
    (cond
      ((null l) l)
      ((null (tail l)) l)
      (t (join-sorted (sort (head (halves l)) f) (sort (head (tail (halves l))) f) f)))))
(sort (list 1 2 3 4 5))
(sort (list 5 4 3 2 1))
(sort (list 1 3 5 3 4 4 2 0))
(sort (list 1 3 5 3 4 4 2 0) >)

(print-line)
"Function with bound scope."
(set 'generate-incrementer
  (lambda ()
    (progn
      (set 'x 0)
      (lambda ()
        (progn
          (set 'x (+ x 1))
          x)))))
(set 'incrementer1 (generate-incrementer))
(incrementer1)
(incrementer1)
(set 'incrementer2 (generate-incrementer))
(incrementer2)
(incrementer1)